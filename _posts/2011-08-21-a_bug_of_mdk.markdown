---
author: dashashi
comments: true
date: 2011-08-21 14:12:19+00:00
layout: post
slug: mdk%e5%9d%91%e7%88%b9%e7%9a%84%e4%b8%80%e4%b8%aabug
title: MDK坑爹的一个bug
wordpress_id: 1358
categories:
- 未分类
tags:
- keil
- MDK
- STM32
---

这两天在测试用SPI读flash，基本上就是照着例程写的，但是怎么都不对 后来照着例程一句一句把代码替换掉，终于发现问题之所在 在定义读flash命令的时候，<!-- more -->我多加了一个h 也就是把原本的 #define sFLASH_CMD_READ 0x03 打成了 #define sFLASH_CMD_READ 0x03h 好吧- -按说这玩意儿应该会报错的，不过MDK不仅没报错，而且给了我发现0X03H被MDK编译成49，也就是0x31 顿时我整个人都法克了……被这玩意儿调戏了一天了…… 于是我又试了一下，定义了一个变量 int d = 1h; 嗯嗯，你认为结过会是什么？报错？1？都不对，结果是66，居然是66，肿么回事- -| 仔细想了一下，恍然大悟，找出ASSCII表，h在ASSCII表中的位置是104，减去'0'的ASCII值48，结果是56，然后加上第一位的10，结果刚好是66…… 为了印证我的想法，我又试了一下int d = 1H;结果不出所料，是34- -|| 我查了一下MDK的帮助文件，里面提到MDK是支持h后缀的16进制常量的，也就是11h可以被编译为17，不过实际上它只实现了一半- -11h成功地通过了语法检查，然后接着编译的时候，11h被认为是一个10进制数，分别减去'0'的ASCII码，然后…… 而坑了我一天的0x03h被认为是个16进制数，不过不过在编译的时候，H被编译为1，可能是减去'a'或者'A'后对6取了一次模然后加上10，abcdefgh，如果f当做5，g当做6的话，f刚好当做7。 不过在数字后面加g或者其他字母都是没法通过编译的，估计是过不了语法检查那一关- -| 嗷……这么个小问题写了这么多…… 不过感觉这个问题挺隐蔽的- -|发出来给大家提个醒，别像我花了一天的时间调试这玩意儿- -|
